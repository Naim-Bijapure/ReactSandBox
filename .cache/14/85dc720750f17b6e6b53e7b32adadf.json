{"id":"../node_modules/@aws-amplify/auth/lib/Auth.js","dependencies":[{"name":"/home/pronoob/Desktop/SandBox/ReactSandBox/node_modules/@aws-amplify/auth/lib/Auth.js.map","includedInParent":true,"mtime":1552201916263},{"name":"/home/pronoob/Desktop/SandBox/ReactSandBox/node_modules/@aws-amplify/auth/src/Auth.ts","includedInParent":true,"mtime":1552201916263},{"name":"/home/pronoob/Desktop/SandBox/ReactSandBox/package.json","includedInParent":true,"mtime":1552220018357},{"name":"/home/pronoob/Desktop/SandBox/ReactSandBox/node_modules/@aws-amplify/auth/package.json","includedInParent":true,"mtime":1552201916263},{"name":"./types","loc":{"line":58,"column":22},"parent":"/home/pronoob/Desktop/SandBox/ReactSandBox/node_modules/@aws-amplify/auth/lib/Auth.js","resolved":"/home/pronoob/Desktop/SandBox/ReactSandBox/node_modules/@aws-amplify/auth/lib/types/index.js"},{"name":"@aws-amplify/core","loc":{"line":59,"column":21},"parent":"/home/pronoob/Desktop/SandBox/ReactSandBox/node_modules/@aws-amplify/auth/lib/Auth.js","resolved":"/home/pronoob/Desktop/SandBox/ReactSandBox/node_modules/@aws-amplify/core/lib/index.js"},{"name":"amazon-cognito-identity-js","loc":{"line":60,"column":43},"parent":"/home/pronoob/Desktop/SandBox/ReactSandBox/node_modules/@aws-amplify/auth/lib/Auth.js","resolved":"/home/pronoob/Desktop/SandBox/ReactSandBox/node_modules/amazon-cognito-identity-js/es/index.js"},{"name":"amazon-cognito-auth-js","loc":{"line":61,"column":39},"parent":"/home/pronoob/Desktop/SandBox/ReactSandBox/node_modules/@aws-amplify/auth/lib/Auth.js","resolved":"/home/pronoob/Desktop/SandBox/ReactSandBox/node_modules/amazon-cognito-auth-js/es/index.js"},{"name":"url","loc":{"line":62,"column":20},"parent":"/home/pronoob/Desktop/SandBox/ReactSandBox/node_modules/@aws-amplify/auth/lib/Auth.js","resolved":"/home/pronoob/Desktop/SandBox/ReactSandBox/node_modules/url/url.js"},{"name":"./urlListener","loc":{"line":63,"column":28},"parent":"/home/pronoob/Desktop/SandBox/ReactSandBox/node_modules/@aws-amplify/auth/lib/Auth.js","resolved":"/home/pronoob/Desktop/SandBox/ReactSandBox/node_modules/@aws-amplify/auth/lib/urlListener.js"}],"generated":{"js":"\"use strict\";\n/*\n * Copyright 2017-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar types_1 = require(\"./types\");\nvar core_1 = require(\"@aws-amplify/core\");\nvar amazon_cognito_identity_js_1 = require(\"amazon-cognito-identity-js\");\nvar amazon_cognito_auth_js_1 = require(\"amazon-cognito-auth-js\");\nvar url_1 = require(\"url\");\nvar urlListener_1 = require(\"./urlListener\");\nvar logger = new core_1.ConsoleLogger('AuthClass');\nvar dispatchAuthEvent = function (event, data) {\n    core_1.Hub.dispatch('auth', { event: event, data: data }, 'Auth');\n};\nvar CognitoHostedUIIdentityProvider;\n(function (CognitoHostedUIIdentityProvider) {\n    CognitoHostedUIIdentityProvider[\"Cognito\"] = \"COGNITO\";\n    CognitoHostedUIIdentityProvider[\"Google\"] = \"Google\";\n    CognitoHostedUIIdentityProvider[\"Facebook\"] = \"Facebook\";\n    CognitoHostedUIIdentityProvider[\"Amazon\"] = \"LoginWithAmazon\";\n})(CognitoHostedUIIdentityProvider = exports.CognitoHostedUIIdentityProvider || (exports.CognitoHostedUIIdentityProvider = {}));\n/**\n* Provide authentication steps\n*/\nvar AuthClass = /** @class */ (function () {\n    /**\n     * Initialize Auth with AWS configurations\n     * @param {Object} config - Configuration of the Auth\n     */\n    function AuthClass(config) {\n        this.userPool = null;\n        this._cognitoAuthClient = null;\n        this.user = null;\n        this.configure(config);\n        this.currentUserCredentials = this.currentUserCredentials.bind(this);\n        if (core_1.AWS.config) {\n            core_1.AWS.config.update({ customUserAgent: core_1.Constants.userAgent });\n        }\n        else {\n            logger.warn('No AWS.config');\n        }\n    }\n    AuthClass.prototype.getModuleName = function () {\n        return 'Auth';\n    };\n    AuthClass.prototype.configure = function (config) {\n        var _this = this;\n        if (!config)\n            return this._config || {};\n        logger.debug('configure Auth');\n        var conf = Object.assign({}, this._config, core_1.Parser.parseMobilehubConfig(config).Auth, config);\n        this._config = conf;\n        var _a = this._config, userPoolId = _a.userPoolId, userPoolWebClientId = _a.userPoolWebClientId, cookieStorage = _a.cookieStorage, oauth = _a.oauth, region = _a.region, identityPoolId = _a.identityPoolId, mandatorySignIn = _a.mandatorySignIn, refreshHandlers = _a.refreshHandlers, identityPoolRegion = _a.identityPoolRegion;\n        if (!this._config.storage) {\n            // backward compatbility\n            if (cookieStorage)\n                this._storage = new amazon_cognito_identity_js_1.CookieStorage(cookieStorage);\n            else {\n                this._storage = new core_1.StorageHelper().getStorage();\n            }\n        }\n        else {\n            this._storage = this._config.storage;\n        }\n        this._storageSync = Promise.resolve();\n        if (typeof this._storage['sync'] === 'function') {\n            this._storageSync = this._storage['sync']();\n        }\n        if (userPoolId) {\n            var userPoolData = {\n                UserPoolId: userPoolId,\n                ClientId: userPoolWebClientId,\n            };\n            userPoolData.Storage = this._storage;\n            this.userPool = new amazon_cognito_identity_js_1.CognitoUserPool(userPoolData);\n        }\n        core_1.Credentials.configure({\n            mandatorySignIn: mandatorySignIn,\n            region: identityPoolRegion || region,\n            userPoolId: userPoolId,\n            identityPoolId: identityPoolId,\n            refreshHandlers: refreshHandlers,\n            storage: this._storage\n        });\n        // initiailize cognitoauth client if hosted ui options provided\n        // to keep backward compatibility:\n        var cognitoHostedUIConfig = oauth\n            ? (oauth['domain'] ? oauth : oauth.awsCognito)\n            : undefined;\n        if (cognitoHostedUIConfig) {\n            var that_1 = this;\n            var _b = cognitoHostedUIConfig, AppWebDomain = _b.domain, TokenScopesArray = _b.scope, RedirectUriSignIn = _b.redirectSignIn, RedirectUriSignOut = _b.redirectSignOut, ResponseType = _b.responseType, urlOpener_1 = _b.urlOpener, options = _b.options;\n            // TODO: remove this once we refactor web browser support\n            var LaunchUri = urlOpener_1;\n            if (typeof LaunchUri === 'function') {\n                LaunchUri = function (url, redirectUrl) {\n                    var _a = (url_1.parse(url || '').query || '')\n                        .split('&')\n                        .filter(Boolean)\n                        .map(function (param) { return param.split('='); })\n                        .reduce(function (r, _a) {\n                        var k = _a[0], v = _a[1];\n                        var _b;\n                        return (__assign({}, r, (_b = {}, _b[k] = decodeURIComponent(v), _b)));\n                    }, {}), redirect_uri = _a.redirect_uri, logout_uri = _a.logout_uri;\n                    // If no redirectUrl was provided, we take it from the query string.\n                    // (redirect_uri first, then logout_uri).\n                    return urlOpener_1(url, redirectUrl || redirect_uri || logout_uri);\n                };\n            }\n            var cognitoAuthParams_1 = {\n                ClientId: userPoolWebClientId,\n                UserPoolId: userPoolId,\n                AppWebDomain: AppWebDomain,\n                TokenScopesArray: TokenScopesArray,\n                RedirectUriSignIn: RedirectUriSignIn,\n                RedirectUriSignOut: RedirectUriSignOut,\n                ResponseType: ResponseType,\n                Storage: this._storage,\n                LaunchUri: LaunchUri,\n                options: options\n            };\n            urlListener_1.default(function (_a) {\n                var url = _a.url;\n                logger.debug('cognito auth params', cognitoAuthParams_1);\n                _this._cognitoAuthClient = new amazon_cognito_auth_js_1.CognitoAuth(cognitoAuthParams_1);\n                _this._cognitoAuthClient.userhandler = {\n                    // user signed in\n                    onSuccess: function (result) {\n                        that_1.user = that_1.userPool.getCurrentUser();\n                        logger.debug(\"Cognito Hosted authentication result\", result);\n                        that_1.currentSession().then(function (session) { return __awaiter(_this, void 0, void 0, function () {\n                            var cred, e_1;\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0:\n                                        _a.trys.push([0, 3, 4, 5]);\n                                        return [4 /*yield*/, core_1.Credentials.clear()];\n                                    case 1:\n                                        _a.sent();\n                                        return [4 /*yield*/, core_1.Credentials.set(session, 'session')];\n                                    case 2:\n                                        cred = _a.sent();\n                                        logger.debug('sign in succefully with', cred);\n                                        return [3 /*break*/, 5];\n                                    case 3:\n                                        e_1 = _a.sent();\n                                        logger.debug('sign in without aws credentials', e_1);\n                                        return [3 /*break*/, 5];\n                                    case 4:\n                                        dispatchAuthEvent('signIn', that_1.user);\n                                        dispatchAuthEvent('cognitoHostedUI', that_1.user);\n                                        return [7 /*endfinally*/];\n                                    case 5: return [2 /*return*/];\n                                }\n                            });\n                        }); });\n                    },\n                    onFailure: function (err) {\n                        logger.debug(\"Error in cognito hosted auth response\", err);\n                        dispatchAuthEvent('signIn_failure', err);\n                        dispatchAuthEvent('cognitoHostedUI_failure', err);\n                    }\n                };\n                // if not logged in, try to parse the url.\n                _this.currentAuthenticatedUser().then(function () {\n                    logger.debug('user already logged in');\n                }).catch(function (_e) {\n                    try {\n                        _this._cognitoAuthClient.parseCognitoWebResponse(url);\n                    }\n                    catch (err) {\n                        logger.debug('something wrong when parsing the url', err);\n                        dispatchAuthEvent('parsingUrl_failure', null);\n                    }\n                });\n            });\n        }\n        dispatchAuthEvent('configured', null);\n        return this._config;\n    };\n    /**\n     * Sign up with username, password and other attrbutes like phone, email\n     * @param {String | object} params - The user attirbutes used for signin\n     * @param {String[]} restOfAttrs - for the backward compatability\n     * @return - A promise resolves callback data if success\n     */\n    AuthClass.prototype.signUp = function (params) {\n        var _this = this;\n        var restOfAttrs = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            restOfAttrs[_i - 1] = arguments[_i];\n        }\n        if (!this.userPool) {\n            return Promise.reject('No userPool');\n        }\n        var username = null;\n        var password = null;\n        var attributes = [];\n        var validationData = null;\n        if (params && typeof params === 'string') {\n            username = params;\n            password = restOfAttrs ? restOfAttrs[0] : null;\n            var email = restOfAttrs ? restOfAttrs[1] : null;\n            var phone_number = restOfAttrs ? restOfAttrs[2] : null;\n            if (email)\n                attributes.push({ Name: 'email', Value: email });\n            if (phone_number)\n                attributes.push({ Name: 'phone_number', Value: phone_number });\n        }\n        else if (params && typeof params === 'object') {\n            username = params['username'];\n            password = params['password'];\n            var attrs_1 = params['attributes'];\n            if (attrs_1) {\n                Object.keys(attrs_1).map(function (key) {\n                    var ele = { Name: key, Value: attrs_1[key] };\n                    attributes.push(ele);\n                });\n            }\n            validationData = params['validationData'] || null;\n        }\n        else {\n            return Promise.reject('The first parameter should either be non-null string or object');\n        }\n        if (!username) {\n            return Promise.reject('Username cannot be empty');\n        }\n        if (!password) {\n            return Promise.reject('Password cannot be empty');\n        }\n        logger.debug('signUp attrs:', attributes);\n        logger.debug('signUp validation data:', validationData);\n        return new Promise(function (resolve, reject) {\n            _this.userPool.signUp(username, password, attributes, validationData, function (err, data) {\n                if (err) {\n                    dispatchAuthEvent('signUp_failure', err);\n                    reject(err);\n                }\n                else {\n                    dispatchAuthEvent('signUp', data);\n                    resolve(data);\n                }\n            });\n        });\n    };\n    /**\n     * Send the verfication code to confirm sign up\n     * @param {String} username - The username to be confirmed\n     * @param {String} code - The verification code\n     * @param {ConfirmSignUpOptions} options - other options for confirm signup\n     * @return - A promise resolves callback data if success\n     */\n    AuthClass.prototype.confirmSignUp = function (username, code, options) {\n        if (!this.userPool) {\n            return Promise.reject('No userPool');\n        }\n        if (!username) {\n            return Promise.reject('Username cannot be empty');\n        }\n        if (!code) {\n            return Promise.reject('Code cannot be empty');\n        }\n        var user = this.createCognitoUser(username);\n        var forceAliasCreation = options && typeof options.forceAliasCreation === 'boolean'\n            ? options.forceAliasCreation : true;\n        return new Promise(function (resolve, reject) {\n            user.confirmRegistration(code, forceAliasCreation, function (err, data) {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(data);\n                }\n            });\n        });\n    };\n    /**\n     * Resend the verification code\n     * @param {String} username - The username to be confirmed\n     * @return - A promise resolves data if success\n     */\n    AuthClass.prototype.resendSignUp = function (username) {\n        if (!this.userPool) {\n            return Promise.reject('No userPool');\n        }\n        if (!username) {\n            return Promise.reject('Username cannot be empty');\n        }\n        var user = this.createCognitoUser(username);\n        return new Promise(function (resolve, reject) {\n            user.resendConfirmationCode(function (err, data) {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(data);\n                }\n            });\n        });\n    };\n    /**\n     * Sign in\n     * @param {String | SignInOpts} usernameOrSignInOpts - The username to be signed in or the sign in options\n     * @param {String} password - The password of the username\n     * @return - A promise resolves the CognitoUser\n     */\n    AuthClass.prototype.signIn = function (usernameOrSignInOpts, pw) {\n        if (!this.userPool) {\n            return Promise.reject('No userPool');\n        }\n        var username = null;\n        var password = null;\n        var validationData = {};\n        // for backward compatibility\n        if (typeof usernameOrSignInOpts === 'string') {\n            username = usernameOrSignInOpts;\n            password = pw;\n        }\n        else if (types_1.isUsernamePasswordOpts(usernameOrSignInOpts)) {\n            if (typeof pw !== 'undefined') {\n                logger.warn('The password should be defined under the first parameter object!');\n            }\n            username = usernameOrSignInOpts.username;\n            password = usernameOrSignInOpts.password;\n            validationData = usernameOrSignInOpts.validationData;\n        }\n        else {\n            return Promise.reject(new Error('The username should either be a string or one of the sign in types'));\n        }\n        if (!username) {\n            return Promise.reject('Username cannot be empty');\n        }\n        var authDetails = new amazon_cognito_identity_js_1.AuthenticationDetails({\n            Username: username,\n            Password: password,\n            ValidationData: validationData\n        });\n        if (password) {\n            return this.signInWithPassword(authDetails);\n        }\n        else {\n            return this.signInWithoutPassword(authDetails);\n        }\n    };\n    /**\n     * Return an object with the authentication callbacks\n     * @param {CognitoUser} user - the cognito user object\n     * @param {} resolve - function called when resolving the current step\n     * @param {} reject - function called when rejecting the current step\n     * @return - an object with the callback methods for user authentication\n     */\n    AuthClass.prototype.authCallbacks = function (user, resolve, reject) {\n        var _this = this;\n        var that = this;\n        return {\n            onSuccess: function (session) { return __awaiter(_this, void 0, void 0, function () {\n                var cred, e_2;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            logger.debug(session);\n                            delete (user['challengeName']);\n                            delete (user['challengeParam']);\n                            _a.label = 1;\n                        case 1:\n                            _a.trys.push([1, 4, 5, 6]);\n                            return [4 /*yield*/, core_1.Credentials.clear()];\n                        case 2:\n                            _a.sent();\n                            return [4 /*yield*/, core_1.Credentials.set(session, 'session')];\n                        case 3:\n                            cred = _a.sent();\n                            logger.debug('succeed to get cognito credentials', cred);\n                            return [3 /*break*/, 6];\n                        case 4:\n                            e_2 = _a.sent();\n                            logger.debug('cannot get cognito credentials', e_2);\n                            return [3 /*break*/, 6];\n                        case 5:\n                            that.user = user;\n                            dispatchAuthEvent('signIn', user);\n                            resolve(user);\n                            return [7 /*endfinally*/];\n                        case 6: return [2 /*return*/];\n                    }\n                });\n            }); },\n            onFailure: function (err) {\n                logger.debug('signIn failure', err);\n                dispatchAuthEvent('signIn_failure', err);\n                reject(err);\n            },\n            customChallenge: function (challengeParam) {\n                logger.debug('signIn custom challenge answer required');\n                user['challengeName'] = 'CUSTOM_CHALLENGE';\n                user['challengeParam'] = challengeParam;\n                resolve(user);\n            },\n            mfaRequired: function (challengeName, challengeParam) {\n                logger.debug('signIn MFA required');\n                user['challengeName'] = challengeName;\n                user['challengeParam'] = challengeParam;\n                resolve(user);\n            },\n            mfaSetup: function (challengeName, challengeParam) {\n                logger.debug('signIn mfa setup', challengeName);\n                user['challengeName'] = challengeName;\n                user['challengeParam'] = challengeParam;\n                resolve(user);\n            },\n            newPasswordRequired: function (userAttributes, requiredAttributes) {\n                logger.debug('signIn new password');\n                user['challengeName'] = 'NEW_PASSWORD_REQUIRED';\n                user['challengeParam'] = {\n                    userAttributes: userAttributes,\n                    requiredAttributes: requiredAttributes\n                };\n                resolve(user);\n            },\n            totpRequired: function (challengeName, challengeParam) {\n                logger.debug('signIn totpRequired');\n                user['challengeName'] = challengeName;\n                user['challengeParam'] = challengeParam;\n                resolve(user);\n            },\n            selectMFAType: function (challengeName, challengeParam) {\n                logger.debug('signIn selectMFAType', challengeName);\n                user['challengeName'] = challengeName;\n                user['challengeParam'] = challengeParam;\n                resolve(user);\n            }\n        };\n    };\n    /**\n     * Sign in with a password\n     * @private\n     * @param {AuthenticationDetails} authDetails - the user sign in data\n     * @return - A promise resolves the CognitoUser object if success or mfa required\n     */\n    AuthClass.prototype.signInWithPassword = function (authDetails) {\n        var _this = this;\n        var user = this.createCognitoUser(authDetails.getUsername());\n        return new Promise(function (resolve, reject) {\n            user.authenticateUser(authDetails, _this.authCallbacks(user, resolve, reject));\n        });\n    };\n    /**\n     * Sign in without a password\n     * @private\n     * @param {AuthenticationDetails} authDetails - the user sign in data\n     * @return - A promise resolves the CognitoUser object if success or mfa required\n     */\n    AuthClass.prototype.signInWithoutPassword = function (authDetails) {\n        var _this = this;\n        var user = this.createCognitoUser(authDetails.getUsername());\n        user.setAuthenticationFlowType('CUSTOM_AUTH');\n        return new Promise(function (resolve, reject) {\n            user.initiateAuth(authDetails, _this.authCallbacks(user, resolve, reject));\n        });\n    };\n    /**\n     * get user current preferred mfa option\n     * this method doesn't work with totp, we need to deprecate it.\n     * @deprecated\n     * @param {CognitoUser} user - the current user\n     * @return - A promise resolves the current preferred mfa option if success\n     */\n    AuthClass.prototype.getMFAOptions = function (user) {\n        return new Promise(function (res, rej) {\n            user.getMFAOptions(function (err, mfaOptions) {\n                if (err) {\n                    logger.debug('get MFA Options failed', err);\n                    rej(err);\n                    return;\n                }\n                logger.debug('get MFA options success', mfaOptions);\n                res(mfaOptions);\n                return;\n            });\n        });\n    };\n    /**\n     * get preferred mfa method\n     * @param {CognitoUser} user - the current cognito user\n     */\n    AuthClass.prototype.getPreferredMFA = function (user) {\n        var that = this;\n        return new Promise(function (res, rej) {\n            user.getUserData(function (err, data) {\n                if (err) {\n                    logger.debug('getting preferred mfa failed', err);\n                    rej(err);\n                    return;\n                }\n                var mfaType = that._getMfaTypeFromUserData(data);\n                if (!mfaType) {\n                    rej('invalid MFA Type');\n                    return;\n                }\n                else {\n                    res(mfaType);\n                    return;\n                }\n            });\n        });\n    };\n    AuthClass.prototype._getMfaTypeFromUserData = function (data) {\n        var ret = null;\n        var preferredMFA = data.PreferredMfaSetting;\n        // if the user has used Auth.setPreferredMFA() to setup the mfa type\n        // then the \"PreferredMfaSetting\" would exist in the response\n        if (preferredMFA) {\n            ret = preferredMFA;\n        }\n        else {\n            // if mfaList exists but empty, then its noMFA\n            var mfaList = data.UserMFASettingList;\n            if (!mfaList) {\n                // if SMS was enabled by using Auth.enableSMS(),\n                // the response would contain MFAOptions\n                // as for now Cognito only supports for SMS, so we will say it is 'SMS_MFA'\n                // if it does not exist, then it should be NOMFA\n                var MFAOptions = data.MFAOptions;\n                if (MFAOptions) {\n                    ret = 'SMS_MFA';\n                }\n                else {\n                    ret = 'NOMFA';\n                }\n            }\n            else if (mfaList.length === 0) {\n                ret = 'NOMFA';\n            }\n            else {\n                logger.debug('invalid case for getPreferredMFA', data);\n            }\n        }\n        return ret;\n    };\n    AuthClass.prototype._getUserData = function (user) {\n        return new Promise(function (res, rej) {\n            user.getUserData(function (err, data) {\n                if (err) {\n                    logger.debug('getting user data failed', err);\n                    rej(err);\n                    return;\n                }\n                else {\n                    res(data);\n                    return;\n                }\n            });\n        });\n    };\n    /**\n     * set preferred MFA method\n     * @param {CognitoUser} user - the current Cognito user\n     * @param {string} mfaMethod - preferred mfa method\n     * @return - A promise resolve if success\n     */\n    AuthClass.prototype.setPreferredMFA = function (user, mfaMethod) {\n        return __awaiter(this, void 0, void 0, function () {\n            var userData, smsMfaSettings, totpMfaSettings, _a, mfaList, currentMFAType, that;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, this._getUserData(user)];\n                    case 1:\n                        userData = _b.sent();\n                        smsMfaSettings = null;\n                        totpMfaSettings = null;\n                        _a = mfaMethod;\n                        switch (_a) {\n                            case 'TOTP' || 'SOFTWARE_TOKEN_MFA': return [3 /*break*/, 2];\n                            case 'SMS' || 'SMS_MFA': return [3 /*break*/, 3];\n                            case 'NOMFA': return [3 /*break*/, 4];\n                        }\n                        return [3 /*break*/, 6];\n                    case 2:\n                        totpMfaSettings = {\n                            PreferredMfa: true,\n                            Enabled: true\n                        };\n                        return [3 /*break*/, 7];\n                    case 3:\n                        smsMfaSettings = {\n                            PreferredMfa: true,\n                            Enabled: true\n                        };\n                        return [3 /*break*/, 7];\n                    case 4:\n                        mfaList = userData['UserMFASettingList'];\n                        return [4 /*yield*/, this._getMfaTypeFromUserData(userData)];\n                    case 5:\n                        currentMFAType = _b.sent();\n                        if (currentMFAType === 'NOMFA') {\n                            return [2 /*return*/, Promise.resolve('No change for mfa type')];\n                        }\n                        else if (currentMFAType === 'SMS_MFA') {\n                            smsMfaSettings = {\n                                PreferredMfa: false,\n                                Enabled: false\n                            };\n                        }\n                        else if (currentMFAType === 'SOFTWARE_TOKEN_MFA') {\n                            totpMfaSettings = {\n                                PreferredMfa: false,\n                                Enabled: false\n                            };\n                        }\n                        else {\n                            return [2 /*return*/, Promise.reject('invalid MFA type')];\n                        }\n                        // if there is a UserMFASettingList in the response\n                        // we need to disable every mfa type in that list\n                        if (mfaList && mfaList.length !== 0) {\n                            // to disable SMS or TOTP if exists in that list\n                            mfaList.forEach(function (mfaType) {\n                                if (mfaType === 'SMS_MFA') {\n                                    smsMfaSettings = {\n                                        PreferredMfa: false,\n                                        Enabled: false\n                                    };\n                                }\n                                else if (mfaType === 'SOFTWARE_TOKEN_MFA') {\n                                    totpMfaSettings = {\n                                        PreferredMfa: false,\n                                        Enabled: false\n                                    };\n                                }\n                            });\n                        }\n                        return [3 /*break*/, 7];\n                    case 6:\n                        logger.debug('no validmfa method provided');\n                        return [2 /*return*/, Promise.reject('no validmfa method provided')];\n                    case 7:\n                        that = this;\n                        return [2 /*return*/, new Promise(function (res, rej) {\n                                user.setUserMfaPreference(smsMfaSettings, totpMfaSettings, function (err, result) {\n                                    if (err) {\n                                        logger.debug('Set user mfa preference error', err);\n                                        return rej(err);\n                                    }\n                                    logger.debug('Set user mfa success', result);\n                                    return res(result);\n                                });\n                            })];\n                }\n            });\n        });\n    };\n    /**\n     * diable SMS\n     * @deprecated\n     * @param {CognitoUser} user - the current user\n     * @return - A promise resolves is success\n     */\n    AuthClass.prototype.disableSMS = function (user) {\n        return new Promise(function (res, rej) {\n            user.disableMFA(function (err, data) {\n                if (err) {\n                    logger.debug('disable mfa failed', err);\n                    rej(err);\n                    return;\n                }\n                logger.debug('disable mfa succeed', data);\n                res(data);\n                return;\n            });\n        });\n    };\n    /**\n     * enable SMS\n     * @deprecated\n     * @param {CognitoUser} user - the current user\n     * @return - A promise resolves is success\n     */\n    AuthClass.prototype.enableSMS = function (user) {\n        return new Promise(function (res, rej) {\n            user.enableMFA(function (err, data) {\n                if (err) {\n                    logger.debug('enable mfa failed', err);\n                    rej(err);\n                    return;\n                }\n                logger.debug('enable mfa succeed', data);\n                res(data);\n                return;\n            });\n        });\n    };\n    /**\n     * Setup TOTP\n     * @param {CognitoUser} user - the current user\n     * @return - A promise resolves with the secret code if success\n     */\n    AuthClass.prototype.setupTOTP = function (user) {\n        return new Promise(function (res, rej) {\n            user.associateSoftwareToken({\n                onFailure: function (err) {\n                    logger.debug('associateSoftwareToken failed', err);\n                    rej(err);\n                    return;\n                },\n                associateSecretCode: function (secretCode) {\n                    logger.debug('associateSoftwareToken sucess', secretCode);\n                    res(secretCode);\n                    return;\n                }\n            });\n        });\n    };\n    /**\n     * verify TOTP setup\n     * @param {CognitoUser} user - the current user\n     * @param {string} challengeAnswer - challenge answer\n     * @return - A promise resolves is success\n     */\n    AuthClass.prototype.verifyTotpToken = function (user, challengeAnswer) {\n        logger.debug('verfication totp token', user, challengeAnswer);\n        return new Promise(function (res, rej) {\n            user.verifySoftwareToken(challengeAnswer, 'My TOTP device', {\n                onFailure: function (err) {\n                    logger.debug('verifyTotpToken failed', err);\n                    rej(err);\n                    return;\n                },\n                onSuccess: function (data) {\n                    logger.debug('verifyTotpToken success', data);\n                    res(data);\n                    return;\n                }\n            });\n        });\n    };\n    /**\n     * Send MFA code to confirm sign in\n     * @param {Object} user - The CognitoUser object\n     * @param {String} code - The confirmation code\n     */\n    AuthClass.prototype.confirmSignIn = function (user, code, mfaType) {\n        var _this = this;\n        if (!code) {\n            return Promise.reject('Code cannot be empty');\n        }\n        var that = this;\n        return new Promise(function (resolve, reject) {\n            user.sendMFACode(code, {\n                onSuccess: function (session) { return __awaiter(_this, void 0, void 0, function () {\n                    var cred, e_3;\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                logger.debug(session);\n                                _a.label = 1;\n                            case 1:\n                                _a.trys.push([1, 4, 5, 6]);\n                                return [4 /*yield*/, core_1.Credentials.clear()];\n                            case 2:\n                                _a.sent();\n                                return [4 /*yield*/, core_1.Credentials.set(session, 'session')];\n                            case 3:\n                                cred = _a.sent();\n                                logger.debug('succeed to get cognito credentials', cred);\n                                return [3 /*break*/, 6];\n                            case 4:\n                                e_3 = _a.sent();\n                                logger.debug('cannot get cognito credentials', e_3);\n                                return [3 /*break*/, 6];\n                            case 5:\n                                that.user = user;\n                                dispatchAuthEvent('signIn', user);\n                                resolve(user);\n                                return [7 /*endfinally*/];\n                            case 6: return [2 /*return*/];\n                        }\n                    });\n                }); },\n                onFailure: function (err) {\n                    logger.debug('confirm signIn failure', err);\n                    reject(err);\n                }\n            }, mfaType);\n        });\n    };\n    AuthClass.prototype.completeNewPassword = function (user, password, requiredAttributes) {\n        var _this = this;\n        if (!password) {\n            return Promise.reject('Password cannot be empty');\n        }\n        var that = this;\n        return new Promise(function (resolve, reject) {\n            user.completeNewPasswordChallenge(password, requiredAttributes, {\n                onSuccess: function (session) { return __awaiter(_this, void 0, void 0, function () {\n                    var cred, e_4;\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                logger.debug(session);\n                                _a.label = 1;\n                            case 1:\n                                _a.trys.push([1, 4, 5, 6]);\n                                return [4 /*yield*/, core_1.Credentials.clear()];\n                            case 2:\n                                _a.sent();\n                                return [4 /*yield*/, core_1.Credentials.set(session, 'session')];\n                            case 3:\n                                cred = _a.sent();\n                                logger.debug('succeed to get cognito credentials', cred);\n                                return [3 /*break*/, 6];\n                            case 4:\n                                e_4 = _a.sent();\n                                logger.debug('cannot get cognito credentials', e_4);\n                                return [3 /*break*/, 6];\n                            case 5:\n                                that.user = user;\n                                dispatchAuthEvent('signIn', user);\n                                resolve(user);\n                                return [7 /*endfinally*/];\n                            case 6: return [2 /*return*/];\n                        }\n                    });\n                }); },\n                onFailure: function (err) {\n                    logger.debug('completeNewPassword failure', err);\n                    dispatchAuthEvent('completeNewPassword_failure', err);\n                    reject(err);\n                },\n                mfaRequired: function (challengeName, challengeParam) {\n                    logger.debug('signIn MFA required');\n                    user['challengeName'] = challengeName;\n                    user['challengeParam'] = challengeParam;\n                    resolve(user);\n                },\n                mfaSetup: function (challengeName, challengeParam) {\n                    logger.debug('signIn mfa setup', challengeName);\n                    user['challengeName'] = challengeName;\n                    user['challengeParam'] = challengeParam;\n                    resolve(user);\n                }\n            });\n        });\n    };\n    /**\n     * Send the answer to a custom challenge\n     * @param {CognitoUser} user - The CognitoUser object\n     * @param {String} challengeResponses - The confirmation code\n     */\n    AuthClass.prototype.sendCustomChallengeAnswer = function (user, challengeResponses) {\n        var _this = this;\n        if (!this.userPool) {\n            return Promise.reject('No userPool');\n        }\n        if (!challengeResponses) {\n            return Promise.reject('Challenge response cannot be empty');\n        }\n        var that = this;\n        return new Promise(function (resolve, reject) {\n            user.sendCustomChallengeAnswer(challengeResponses, _this.authCallbacks(user, resolve, reject));\n        });\n    };\n    /**\n     * Update an authenticated users' attributes\n     * @param {CognitoUser} - The currently logged in user object\n     * @return {Promise}\n     **/\n    AuthClass.prototype.updateUserAttributes = function (user, attributes) {\n        var attributeList = [];\n        var that = this;\n        return new Promise(function (resolve, reject) {\n            that.userSession(user).then(function (session) {\n                for (var key in attributes) {\n                    if (key !== 'sub' &&\n                        key.indexOf('_verified') < 0) {\n                        var attr = {\n                            'Name': key,\n                            'Value': attributes[key]\n                        };\n                        attributeList.push(attr);\n                    }\n                }\n                user.updateAttributes(attributeList, function (err, result) {\n                    if (err) {\n                        return reject(err);\n                    }\n                    else {\n                        return resolve(result);\n                    }\n                });\n            });\n        });\n    };\n    /**\n     * Return user attributes\n     * @param {Object} user - The CognitoUser object\n     * @return - A promise resolves to user attributes if success\n     */\n    AuthClass.prototype.userAttributes = function (user) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            _this.userSession(user).then(function (session) {\n                user.getUserAttributes(function (err, attributes) {\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        resolve(attributes);\n                    }\n                });\n            });\n        });\n    };\n    AuthClass.prototype.verifiedContact = function (user) {\n        var that = this;\n        return this.userAttributes(user)\n            .then(function (attributes) {\n            var attrs = that.attributesToObject(attributes);\n            var unverified = {};\n            var verified = {};\n            if (attrs['email']) {\n                if (attrs['email_verified']) {\n                    verified['email'] = attrs['email'];\n                }\n                else {\n                    unverified['email'] = attrs['email'];\n                }\n            }\n            if (attrs['phone_number']) {\n                if (attrs['phone_number_verified']) {\n                    verified['phone_number'] = attrs['phone_number'];\n                }\n                else {\n                    unverified['phone_number'] = attrs['phone_number'];\n                }\n            }\n            return {\n                verified: verified,\n                unverified: unverified\n            };\n        });\n    };\n    /**\n     * Get current authenticated user\n     * @return - A promise resolves to current authenticated CognitoUser if success\n     */\n    AuthClass.prototype.currentUserPoolUser = function (params) {\n        var _this = this;\n        if (!this.userPool) {\n            return Promise.reject('No userPool');\n        }\n        var that = this;\n        return new Promise(function (res, rej) {\n            _this._storageSync.then(function () {\n                var user = that.userPool.getCurrentUser();\n                if (!user) {\n                    logger.debug('Failed to get user from user pool');\n                    rej('No current user');\n                    return;\n                }\n                // refresh the session if the session expired.\n                user.getSession(function (err, session) {\n                    if (err) {\n                        logger.debug('Failed to get the user session', err);\n                        rej(err);\n                        return;\n                    }\n                    // get user data from Cognito\n                    var bypassCache = params ? params.bypassCache : false;\n                    user.getUserData(function (err, data) {\n                        if (err) {\n                            logger.debug('getting user data failed', err);\n                            // Make sure the user is still valid\n                            if (err.message === 'User is disabled' || err.message === 'User does not exist.') {\n                                rej(err);\n                            }\n                            else {\n                                // the error may also be thrown when lack of permissions to get user info etc\n                                // in that case we just bypass the error\n                                res(user);\n                            }\n                            return;\n                        }\n                        var preferredMFA = data.PreferredMfaSetting || 'NOMFA';\n                        var attributeList = [];\n                        for (var i = 0; i < data.UserAttributes.length; i++) {\n                            var attribute = {\n                                Name: data.UserAttributes[i].Name,\n                                Value: data.UserAttributes[i].Value,\n                            };\n                            var userAttribute = new amazon_cognito_identity_js_1.CognitoUserAttribute(attribute);\n                            attributeList.push(userAttribute);\n                        }\n                        var attributes = that.attributesToObject(attributeList);\n                        Object.assign(user, { attributes: attributes, preferredMFA: preferredMFA });\n                        return res(user);\n                    }, { bypassCache: bypassCache });\n                });\n            }).catch(function (e) {\n                logger.debug('Failed to sync cache info into memory', e);\n                return rej(e);\n            });\n        });\n    };\n    /**\n     * Get current authenticated user\n     * @param {CurrentUserOpts} - options for getting the current user\n     * @return - A promise resolves to current authenticated CognitoUser if success\n     */\n    AuthClass.prototype.currentAuthenticatedUser = function (params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var federatedUser, e_5, user, e_6;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        logger.debug('getting current authenticted user');\n                        federatedUser = null;\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this._storageSync];\n                    case 2:\n                        _a.sent();\n                        return [3 /*break*/, 4];\n                    case 3:\n                        e_5 = _a.sent();\n                        logger.debug('Failed to sync cache info into memory', e_5);\n                        throw e_5;\n                    case 4:\n                        try {\n                            federatedUser = JSON.parse(this._storage.getItem('aws-amplify-federatedInfo')).user;\n                        }\n                        catch (e) {\n                            logger.debug('cannot load federated user from auth storage');\n                        }\n                        if (!federatedUser) return [3 /*break*/, 5];\n                        this.user = federatedUser;\n                        logger.debug('get current authenticated federated user', this.user);\n                        return [2 /*return*/, this.user];\n                    case 5:\n                        logger.debug('get current authenticated userpool user');\n                        user = null;\n                        _a.label = 6;\n                    case 6:\n                        _a.trys.push([6, 8, , 9]);\n                        return [4 /*yield*/, this.currentUserPoolUser(params)];\n                    case 7:\n                        user = _a.sent();\n                        return [3 /*break*/, 9];\n                    case 8:\n                        e_6 = _a.sent();\n                        if (e_6 === 'No userPool') {\n                            logger.error('Cannot get the current user because the user pool is missing. ' +\n                                'Please make sure the Auth module is configured with a valid Cognito User Pool ID');\n                        }\n                        logger.debug('The user is not authenticated by the error', e_6);\n                        throw ('not authenticated');\n                    case 9:\n                        this.user = user;\n                        return [2 /*return*/, this.user];\n                }\n            });\n        });\n    };\n    /**\n     * Get current user's session\n     * @return - A promise resolves to session object if success\n     */\n    AuthClass.prototype.currentSession = function () {\n        var that = this;\n        logger.debug('Getting current session');\n        if (!this.userPool) {\n            return Promise.reject('No userPool');\n        }\n        return new Promise(function (res, rej) {\n            that.currentUserPoolUser().then(function (user) {\n                that.userSession(user).then(function (session) {\n                    res(session);\n                    return;\n                }).catch(function (e) {\n                    logger.debug('Failed to get the current session', e);\n                    rej(e);\n                    return;\n                });\n            }).catch(function (e) {\n                logger.debug('Failed to get the current user', e);\n                rej(e);\n                return;\n            });\n        });\n    };\n    /**\n     * Get the corresponding user session\n     * @param {Object} user - The CognitoUser object\n     * @return - A promise resolves to the session\n     */\n    AuthClass.prototype.userSession = function (user) {\n        if (!user) {\n            logger.debug('the user is null');\n            return Promise.reject('Failed to get the session because the user is empty');\n        }\n        return new Promise(function (resolve, reject) {\n            logger.debug('Getting the session from this user:', user);\n            user.getSession(function (err, session) {\n                if (err) {\n                    logger.debug('Failed to get the session from user', user);\n                    reject(err);\n                    return;\n                }\n                else {\n                    logger.debug('Succeed to get the user session', session);\n                    resolve(session);\n                    return;\n                }\n            });\n        });\n    };\n    /**\n     * Get  authenticated credentials of current user.\n     * @return - A promise resolves to be current user's credentials\n     */\n    AuthClass.prototype.currentUserCredentials = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var that, e_7, federatedInfo;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        that = this;\n                        logger.debug('Getting current user credentials');\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this._storageSync];\n                    case 2:\n                        _a.sent();\n                        return [3 /*break*/, 4];\n                    case 3:\n                        e_7 = _a.sent();\n                        logger.debug('Failed to sync cache info into memory', e_7);\n                        throw e_7;\n                    case 4:\n                        federatedInfo = null;\n                        try {\n                            federatedInfo = JSON.parse(this._storage.getItem('aws-amplify-federatedInfo'));\n                        }\n                        catch (e) {\n                            logger.debug('failed to get or parse item aws-amplify-federatedInfo', e);\n                        }\n                        if (federatedInfo) {\n                            // refresh the jwt token here if necessary\n                            return [2 /*return*/, core_1.Credentials.refreshFederatedToken(federatedInfo)];\n                        }\n                        else {\n                            return [2 /*return*/, this.currentSession()\n                                    .then(function (session) {\n                                    logger.debug('getting session success', session);\n                                    return core_1.Credentials.set(session, 'session');\n                                }).catch(function (error) {\n                                    logger.debug('getting session failed', error);\n                                    return core_1.Credentials.set(null, 'guest');\n                                })];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AuthClass.prototype.currentCredentials = function () {\n        logger.debug('getting current credntials');\n        return core_1.Credentials.get();\n    };\n    /**\n     * Initiate an attribute confirmation request\n     * @param {Object} user - The CognitoUser\n     * @param {Object} attr - The attributes to be verified\n     * @return - A promise resolves to callback data if success\n     */\n    AuthClass.prototype.verifyUserAttribute = function (user, attr) {\n        return new Promise(function (resolve, reject) {\n            user.getAttributeVerificationCode(attr, {\n                onSuccess: function () { return resolve(); },\n                onFailure: function (err) { return reject(err); }\n            });\n        });\n    };\n    /**\n     * Confirm an attribute using a confirmation code\n     * @param {Object} user - The CognitoUser\n     * @param {Object} attr - The attribute to be verified\n     * @param {String} code - The confirmation code\n     * @return - A promise resolves to callback data if success\n     */\n    AuthClass.prototype.verifyUserAttributeSubmit = function (user, attr, code) {\n        if (!code) {\n            return Promise.reject('Code cannot be empty');\n        }\n        return new Promise(function (resolve, reject) {\n            user.verifyAttribute(attr, code, {\n                onSuccess: function (data) {\n                    resolve(data);\n                    return;\n                },\n                onFailure: function (err) {\n                    reject(err);\n                    return;\n                }\n            });\n        });\n    };\n    AuthClass.prototype.verifyCurrentUserAttribute = function (attr) {\n        var that = this;\n        return that.currentUserPoolUser()\n            .then(function (user) { return that.verifyUserAttribute(user, attr); });\n    };\n    /**\n     * Confirm current user's attribute using a confirmation code\n     * @param {Object} attr - The attribute to be verified\n     * @param {String} code - The confirmation code\n     * @return - A promise resolves to callback data if success\n     */\n    AuthClass.prototype.verifyCurrentUserAttributeSubmit = function (attr, code) {\n        var that = this;\n        return that.currentUserPoolUser()\n            .then(function (user) { return that.verifyUserAttributeSubmit(user, attr, code); });\n    };\n    AuthClass.prototype.cognitoIdentitySignOut = function (opts, user) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                return [2 /*return*/, new Promise(function (res, rej) {\n                        if (opts && opts.global) {\n                            logger.debug('user global sign out', user);\n                            // in order to use global signout\n                            // we must validate the user as an authenticated user by using getSession\n                            user.getSession(function (err, result) {\n                                if (err) {\n                                    logger.debug('failed to get the user session', err);\n                                    return rej(err);\n                                }\n                                user.globalSignOut({\n                                    onSuccess: function (data) {\n                                        logger.debug('global sign out success');\n                                        if (_this._cognitoAuthClient) {\n                                            _this._cognitoAuthClient.signOut();\n                                        }\n                                        return res();\n                                    },\n                                    onFailure: function (err) {\n                                        logger.debug('global sign out failed', err);\n                                        return rej(err);\n                                    }\n                                });\n                            });\n                        }\n                        else {\n                            logger.debug('user sign out', user);\n                            user.signOut();\n                            if (_this._cognitoAuthClient) {\n                                _this._cognitoAuthClient.signOut();\n                            }\n                            return res();\n                        }\n                    })];\n            });\n        });\n    };\n    /**\n     * Sign out method\n     * @\n     * @return - A promise resolved if success\n     */\n    AuthClass.prototype.signOut = function (opts) {\n        return __awaiter(this, void 0, void 0, function () {\n            var e_8, user;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.cleanCachedItems()];\n                    case 1:\n                        _a.sent();\n                        return [3 /*break*/, 3];\n                    case 2:\n                        e_8 = _a.sent();\n                        logger.debug('failed to clear cached items');\n                        return [3 /*break*/, 3];\n                    case 3:\n                        if (!this.userPool) return [3 /*break*/, 7];\n                        user = this.userPool.getCurrentUser();\n                        if (!user) return [3 /*break*/, 5];\n                        return [4 /*yield*/, this.cognitoIdentitySignOut(opts, user)];\n                    case 4:\n                        _a.sent();\n                        return [3 /*break*/, 6];\n                    case 5:\n                        logger.debug('no current Cognito user');\n                        _a.label = 6;\n                    case 6: return [3 /*break*/, 8];\n                    case 7:\n                        logger.debug('no Congito User pool');\n                        _a.label = 8;\n                    case 8:\n                        dispatchAuthEvent('signOut', this.user);\n                        this.user = null;\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AuthClass.prototype.cleanCachedItems = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: \n                    // clear cognito cached item\n                    return [4 /*yield*/, core_1.Credentials.clear()];\n                    case 1:\n                        // clear cognito cached item\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Change a password for an authenticated user\n     * @param {Object} user - The CognitoUser object\n     * @param {String} oldPassword - the current password\n     * @param {String} newPassword - the requested new password\n     * @return - A promise resolves if success\n     */\n    AuthClass.prototype.changePassword = function (user, oldPassword, newPassword) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            _this.userSession(user).then(function (session) {\n                user.changePassword(oldPassword, newPassword, function (err, data) {\n                    if (err) {\n                        logger.debug('change password failure', err);\n                        return reject(err);\n                    }\n                    else {\n                        return resolve(data);\n                    }\n                });\n            });\n        });\n    };\n    /**\n     * Initiate a forgot password request\n     * @param {String} username - the username to change password\n     * @return - A promise resolves if success\n     */\n    AuthClass.prototype.forgotPassword = function (username) {\n        if (!this.userPool) {\n            return Promise.reject('No userPool');\n        }\n        if (!username) {\n            return Promise.reject('Username cannot be empty');\n        }\n        var user = this.createCognitoUser(username);\n        return new Promise(function (resolve, reject) {\n            user.forgotPassword({\n                onSuccess: function () {\n                    resolve();\n                    return;\n                },\n                onFailure: function (err) {\n                    logger.debug('forgot password failure', err);\n                    reject(err);\n                    return;\n                },\n                inputVerificationCode: function (data) {\n                    resolve(data);\n                    return;\n                }\n            });\n        });\n    };\n    /**\n     * Confirm a new password using a confirmation Code\n     * @param {String} username - The username\n     * @param {String} code - The confirmation code\n     * @param {String} password - The new password\n     * @return - A promise that resolves if success\n     */\n    AuthClass.prototype.forgotPasswordSubmit = function (username, code, password) {\n        if (!this.userPool) {\n            return Promise.reject('No userPool');\n        }\n        if (!username) {\n            return Promise.reject('Username cannot be empty');\n        }\n        if (!code) {\n            return Promise.reject('Code cannot be empty');\n        }\n        if (!password) {\n            return Promise.reject('Password cannot be empty');\n        }\n        var user = this.createCognitoUser(username);\n        return new Promise(function (resolve, reject) {\n            user.confirmPassword(code, password, {\n                onSuccess: function () {\n                    resolve();\n                    return;\n                },\n                onFailure: function (err) {\n                    reject(err);\n                    return;\n                }\n            });\n        });\n    };\n    /**\n     * Get user information\n     * @async\n     * @return {Object }- current User's information\n     */\n    AuthClass.prototype.currentUserInfo = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var source, user, attributes, userAttrs, credentials, e_9, info, err_1, user;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        source = core_1.Credentials.getCredSource();\n                        if (!(!source || source === 'aws' || source === 'userPool')) return [3 /*break*/, 9];\n                        return [4 /*yield*/, this.currentUserPoolUser()\n                                .catch(function (err) { return logger.debug(err); })];\n                    case 1:\n                        user = _a.sent();\n                        if (!user) {\n                            return [2 /*return*/, null];\n                        }\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 8, , 9]);\n                        return [4 /*yield*/, this.userAttributes(user)];\n                    case 3:\n                        attributes = _a.sent();\n                        userAttrs = this.attributesToObject(attributes);\n                        credentials = null;\n                        _a.label = 4;\n                    case 4:\n                        _a.trys.push([4, 6, , 7]);\n                        return [4 /*yield*/, this.currentCredentials()];\n                    case 5:\n                        credentials = _a.sent();\n                        return [3 /*break*/, 7];\n                    case 6:\n                        e_9 = _a.sent();\n                        logger.debug('Failed to retrieve credentials while getting current user info', e_9);\n                        return [3 /*break*/, 7];\n                    case 7:\n                        info = {\n                            'id': credentials ? credentials.identityId : undefined,\n                            'username': user.getUsername(),\n                            'attributes': userAttrs\n                        };\n                        return [2 /*return*/, info];\n                    case 8:\n                        err_1 = _a.sent();\n                        logger.debug('currentUserInfo error', err_1);\n                        return [2 /*return*/, {}];\n                    case 9:\n                        if (source === 'federated') {\n                            user = this.user;\n                            return [2 /*return*/, user ? user : {}];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * For federated login\n     * @param {String} provider - federation login provider\n     * @param {FederatedResponse} response - response should have the access token\n     * the identity id (optional)\n     * and the expiration time (the universal time)\n     * @param {String} user - user info\n     */\n    AuthClass.prototype.federatedSignIn = function (provider, response, user) {\n        return __awaiter(this, void 0, void 0, function () {\n            var loggedInUser, e_10, token, identity_id, expires_at, credentials, currentUser;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.currentAuthenticatedUser()];\n                    case 1:\n                        loggedInUser = _a.sent();\n                        logger.warn(\"There is already a signed in user: \" + loggedInUser + \" in your app.\\n                You should not call Auth.federatedSignIn method again as it may cause unexpected behavior.\");\n                        return [3 /*break*/, 3];\n                    case 2:\n                        e_10 = _a.sent();\n                        return [3 /*break*/, 3];\n                    case 3:\n                        token = response.token, identity_id = response.identity_id, expires_at = response.expires_at;\n                        return [4 /*yield*/, core_1.Credentials.set({ provider: provider, token: token, identity_id: identity_id, user: user, expires_at: expires_at }, 'federation')];\n                    case 4:\n                        credentials = _a.sent();\n                        return [4 /*yield*/, this.currentAuthenticatedUser()];\n                    case 5:\n                        currentUser = _a.sent();\n                        dispatchAuthEvent('signIn', currentUser);\n                        logger.debug('federated sign in credentials', credentials);\n                        return [2 /*return*/, credentials];\n                }\n            });\n        });\n    };\n    /**\n     * Compact version of credentials\n     * @param {Object} credentials\n     * @return {Object} - Credentials\n     */\n    AuthClass.prototype.essentialCredentials = function (credentials) {\n        return {\n            accessKeyId: credentials.accessKeyId,\n            sessionToken: credentials.sessionToken,\n            secretAccessKey: credentials.secretAccessKey,\n            identityId: credentials.identityId,\n            authenticated: credentials.authenticated\n        };\n    };\n    AuthClass.prototype.attributesToObject = function (attributes) {\n        var obj = {};\n        if (attributes) {\n            attributes.map(function (attribute) {\n                if (attribute.Value === 'true') {\n                    obj[attribute.Name] = true;\n                }\n                else if (attribute.Value === 'false') {\n                    obj[attribute.Name] = false;\n                }\n                else {\n                    obj[attribute.Name] = attribute.Value;\n                }\n            });\n        }\n        return obj;\n    };\n    AuthClass.prototype.createCognitoUser = function (username) {\n        var userData = {\n            Username: username,\n            Pool: this.userPool,\n        };\n        userData.Storage = this._storage;\n        var authenticationFlowType = this._config.authenticationFlowType;\n        var user = new amazon_cognito_identity_js_1.CognitoUser(userData);\n        if (authenticationFlowType) {\n            user.setAuthenticationFlowType(authenticationFlowType);\n        }\n        return user;\n    };\n    return AuthClass;\n}());\nexports.default = AuthClass;\n"},"sourceMaps":{"js":{"version":3,"file":"Auth.js","sourceRoot":"","sources":["../src/Auth.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2017-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\nimport {\n    AuthOptions,\n    FederatedResponse,\n    SignUpParams,\n    FederatedUser,\n    ConfirmSignUpOptions,\n    SignOutOpts,\n    CurrentUserOpts,\n    SignInOpts,\n    isUsernamePasswordOpts,\n    awsCognitoOAuthOpts\n} from './types';\n\nimport {\n    AWS,\n    ConsoleLogger as Logger,\n    Constants,\n    Hub,\n    JS,\n    Parser,\n    Credentials,\n    StorageHelper,\n    ICredentials,\n    Platform\n} from '@aws-amplify/core';\nimport {\n    CookieStorage,\n    CognitoUserPool,\n    AuthenticationDetails,\n    ICognitoUserPoolData,\n    ICognitoUserData,\n    ISignUpResult,\n    CognitoUser,\n    MFAOption,\n    CognitoUserSession,\n    IAuthenticationCallback,\n    ICognitoUserAttributeData,\n    CognitoUserAttribute\n} from 'amazon-cognito-identity-js';\nimport { CognitoAuth } from 'amazon-cognito-auth-js';\nimport { parse } from 'url';\nimport { default as urlListener } from './urlListener';\n\nconst logger = new Logger('AuthClass');\nconst dispatchAuthEvent = (event, data) => {\n    Hub.dispatch('auth', { event, data }, 'Auth');\n};\n\nexport enum CognitoHostedUIIdentityProvider {\n    Cognito = 'COGNITO',\n    Google = 'Google',\n    Facebook = 'Facebook',\n    Amazon = 'LoginWithAmazon',\n}\n\n/**\n* Provide authentication steps\n*/\nexport default class AuthClass {\n    private _config: AuthOptions;\n    private userPool = null;\n    private _cognitoAuthClient = null;\n    private user:any = null;\n\n    private _storage;\n    private _storageSync;\n\n    /**\n     * Initialize Auth with AWS configurations\n     * @param {Object} config - Configuration of the Auth\n     */\n    constructor(config: AuthOptions) {\n        this.configure(config);\n\n        this.currentUserCredentials = this.currentUserCredentials.bind(this);\n\n        if (AWS.config) {\n            AWS.config.update({customUserAgent: Constants.userAgent});\n        } else {\n            logger.warn('No AWS.config');\n        }\n    }\n\n    public getModuleName() {\n        return 'Auth';\n    }\n\n    configure(config) {\n        if (!config) return this._config || {};\n        logger.debug('configure Auth');\n        const conf = Object.assign({}, this._config, Parser.parseMobilehubConfig(config).Auth, config);\n        this._config = conf;\n        const {\n            userPoolId,\n            userPoolWebClientId,\n            cookieStorage,\n            oauth,\n            region,\n            identityPoolId,\n            mandatorySignIn,\n            refreshHandlers,\n            identityPoolRegion\n        } = this._config;\n\n        if (!this._config.storage) {\n            // backward compatbility\n            if (cookieStorage) this._storage = new CookieStorage(cookieStorage);\n            else {\n                this._storage = new StorageHelper().getStorage();\n            }\n        } else {\n            this._storage = this._config.storage;\n        }\n\n        this._storageSync = Promise.resolve();\n        if (typeof this._storage['sync'] === 'function') {\n            this._storageSync = this._storage['sync']();\n        }\n\n        if (userPoolId) {\n            const userPoolData: ICognitoUserPoolData = {\n                UserPoolId: userPoolId,\n                ClientId: userPoolWebClientId,\n            };\n            userPoolData.Storage = this._storage;\n\n            this.userPool = new CognitoUserPool(userPoolData);\n        }\n\n        Credentials.configure({\n            mandatorySignIn,\n            region: identityPoolRegion || region,\n            userPoolId,\n            identityPoolId,\n            refreshHandlers,\n            storage: this._storage\n        });\n\n        // initiailize cognitoauth client if hosted ui options provided\n        // to keep backward compatibility:\n        const cognitoHostedUIConfig: awsCognitoOAuthOpts = oauth\n            ? (oauth['domain'] ? oauth as awsCognitoOAuthOpts : oauth.awsCognito)\n            : undefined;\n\n        if (cognitoHostedUIConfig) {\n            const that = this;\n            const {\n                domain: AppWebDomain,\n                scope: TokenScopesArray,\n                redirectSignIn: RedirectUriSignIn,\n                redirectSignOut: RedirectUriSignOut,\n                responseType: ResponseType,\n                urlOpener,\n                options\n            } = cognitoHostedUIConfig as awsCognitoOAuthOpts;\n\n            // TODO: remove this once we refactor web browser support\n            let LaunchUri = urlOpener;\n\n            if (typeof LaunchUri === 'function') {\n                LaunchUri = (url: string, redirectUrl?: string) => {\n                    const {\n                        redirect_uri,\n                        logout_uri\n                    } = (parse(url || '').query || '')\n                        .split('&')\n                        .filter(Boolean)\n                        .map(param => param.split('='))\n                        .reduce((r, [k, v]) => ({ ...r, [k]: decodeURIComponent(v) }), {}) as any;\n\n                    // If no redirectUrl was provided, we take it from the query string.\n                    // (redirect_uri first, then logout_uri).\n                    return urlOpener(url, redirectUrl || redirect_uri || logout_uri);\n                };\n            }\n\n            const cognitoAuthParams = {\n                ClientId: userPoolWebClientId,\n                UserPoolId: userPoolId,\n                AppWebDomain,\n                TokenScopesArray,\n                RedirectUriSignIn,\n                RedirectUriSignOut,\n                ResponseType,\n                Storage: this._storage,\n                LaunchUri,\n                options\n            };\n\n            urlListener(({ url }) => {\n                logger.debug('cognito auth params', cognitoAuthParams);\n                this._cognitoAuthClient = new CognitoAuth(cognitoAuthParams);\n                this._cognitoAuthClient.userhandler = {\n                    // user signed in\n                    onSuccess: (result) => {\n                        that.user = that.userPool.getCurrentUser();\n                        logger.debug(\"Cognito Hosted authentication result\", result);\n                        that.currentSession().then(async (session) => {\n                            try {\n                                await Credentials.clear();\n                                const cred = await Credentials.set(session, 'session');\n                                logger.debug('sign in succefully with', cred);\n                            } catch (e) {\n                                logger.debug('sign in without aws credentials', e);\n                            } finally {\n                                dispatchAuthEvent('signIn', that.user);\n                                dispatchAuthEvent('cognitoHostedUI', that.user);\n                            }\n                        });\n                    },\n                    onFailure: (err) => {\n                        logger.debug(\"Error in cognito hosted auth response\", err);\n                        dispatchAuthEvent('signIn_failure', err);\n                        dispatchAuthEvent('cognitoHostedUI_failure', err);\n                    }\n                };\n                // if not logged in, try to parse the url.\n                this.currentAuthenticatedUser().then(() => {\n                    logger.debug('user already logged in');\n                }).catch(_e => {\n                    try {\n                        this._cognitoAuthClient.parseCognitoWebResponse(url);\n                    } catch (err) {\n                        logger.debug('something wrong when parsing the url', err);\n                        dispatchAuthEvent('parsingUrl_failure', null);\n                    }\n                });\n            });\n        }\n\n        dispatchAuthEvent('configured', null);\n        return this._config;\n    }\n\n    /**\n     * Sign up with username, password and other attrbutes like phone, email\n     * @param {String | object} params - The user attirbutes used for signin\n     * @param {String[]} restOfAttrs - for the backward compatability\n     * @return - A promise resolves callback data if success\n     */\n    public signUp(params: string | SignUpParams, ...restOfAttrs: string[]): Promise<ISignUpResult> {\n        if (!this.userPool) { return Promise.reject('No userPool'); }\n\n        let username : string = null;\n        let password : string = null;\n        const attributes : object[] = [];\n        let validationData: object[] = null;\n        if (params && typeof params === 'string') {\n            username = params;\n            password = restOfAttrs? restOfAttrs[0] : null;\n            const email : string = restOfAttrs? restOfAttrs[1] : null;\n            const phone_number : string = restOfAttrs? restOfAttrs[2] : null;\n            if (email) attributes.push({Name: 'email', Value: email});\n            if (phone_number) attributes.push({Name: 'phone_number', Value: phone_number});\n        } else if (params && typeof params === 'object') {\n            username = params['username'];\n            password = params['password'];\n            const attrs = params['attributes'];\n            if (attrs) {\n                Object.keys(attrs).map(key => {\n                    const ele : object = { Name: key, Value: attrs[key] };\n                    attributes.push(ele);\n                });\n            }\n            validationData = params['validationData'] || null;\n        } else {\n            return Promise.reject('The first parameter should either be non-null string or object');\n        }\n\n        if (!username) { return Promise.reject('Username cannot be empty'); }\n        if (!password) { return Promise.reject('Password cannot be empty'); }\n\n        logger.debug('signUp attrs:', attributes);\n        logger.debug('signUp validation data:', validationData);\n\n\n        return new Promise((resolve, reject) => {\n            this.userPool.signUp(username, password, attributes, validationData, function(err, data) {\n                if (err) {\n                    dispatchAuthEvent('signUp_failure', err);\n                    reject(err);\n                } else {\n                    dispatchAuthEvent('signUp', data);\n                    resolve(data);\n                }\n            });\n        });\n    }\n\n    /**\n     * Send the verfication code to confirm sign up\n     * @param {String} username - The username to be confirmed\n     * @param {String} code - The verification code\n     * @param {ConfirmSignUpOptions} options - other options for confirm signup\n     * @return - A promise resolves callback data if success\n     */\n    public confirmSignUp(username: string, code: string, options?: ConfirmSignUpOptions): Promise<any> {\n        if (!this.userPool) { return Promise.reject('No userPool'); }\n        if (!username) { return Promise.reject('Username cannot be empty'); }\n        if (!code) { return Promise.reject('Code cannot be empty'); }\n\n        const user = this.createCognitoUser(username);\n        const forceAliasCreation = options && typeof options.forceAliasCreation === 'boolean'\n            ? options.forceAliasCreation : true;\n\n        return new Promise((resolve, reject) => {\n            user.confirmRegistration(code, forceAliasCreation, function(err, data) {\n                if (err) { reject(err); } else { resolve(data); }\n            });\n        });\n    }\n\n    /**\n     * Resend the verification code\n     * @param {String} username - The username to be confirmed\n     * @return - A promise resolves data if success\n     */\n    public resendSignUp(username: string): Promise<string> {\n        if (!this.userPool) { return Promise.reject('No userPool'); }\n        if (!username) { return Promise.reject('Username cannot be empty'); }\n\n        const user = this.createCognitoUser(username);\n        return new Promise((resolve, reject) => {\n            user.resendConfirmationCode(function(err, data) {\n                if (err) { reject(err); } else { resolve(data); }\n            });\n        });\n    }\n\n    /**\n     * Sign in\n     * @param {String | SignInOpts} usernameOrSignInOpts - The username to be signed in or the sign in options\n     * @param {String} password - The password of the username\n     * @return - A promise resolves the CognitoUser\n     */\n    public signIn(usernameOrSignInOpts: string | SignInOpts, pw?: string): Promise<CognitoUser | any> {\n        if (!this.userPool) { return Promise.reject('No userPool'); }\n        let username = null;\n        let password = null;\n        let validationData = {};\n        // for backward compatibility\n        if (typeof usernameOrSignInOpts === 'string') {\n            username = usernameOrSignInOpts;\n            password = pw;\n        } else if (isUsernamePasswordOpts(usernameOrSignInOpts)) {\n            if (typeof pw !== 'undefined') {\n                logger.warn('The password should be defined under the first parameter object!');\n            }\n            username = usernameOrSignInOpts.username;\n            password = usernameOrSignInOpts.password;\n            validationData = usernameOrSignInOpts.validationData;\n        } else {\n            return Promise.reject(new Error('The username should either be a string or one of the sign in types'));\n        }\n        if (!username) { return Promise.reject('Username cannot be empty'); }\n        const authDetails = new AuthenticationDetails({\n            Username: username,\n            Password: password,\n            ValidationData: validationData\n        });\n        if (password) {\n            return this.signInWithPassword(authDetails);\n        } else {\n            return this.signInWithoutPassword(authDetails);\n        }\n    }\n\n    /**\n     * Return an object with the authentication callbacks\n     * @param {CognitoUser} user - the cognito user object\n     * @param {} resolve - function called when resolving the current step\n     * @param {} reject - function called when rejecting the current step\n     * @return - an object with the callback methods for user authentication\n     */\n    private authCallbacks(\n        user: CognitoUser,\n        resolve: (value?: CognitoUser | any) => void, reject: (value?: any) => void\n    ): IAuthenticationCallback {\n        const that = this;\n        return {\n            onSuccess: async (session) => {\n                logger.debug(session);\n                delete(user['challengeName']);\n                delete(user['challengeParam']);\n                try {\n                    await Credentials.clear();\n                    const cred = await Credentials.set(session, 'session');\n                    logger.debug('succeed to get cognito credentials', cred);\n                } catch (e) {\n                    logger.debug('cannot get cognito credentials', e);\n                } finally {\n                    that.user = user;\n                    dispatchAuthEvent('signIn', user);\n                    resolve(user);\n                }\n            },\n            onFailure: (err) => {\n                logger.debug('signIn failure', err);\n                dispatchAuthEvent('signIn_failure', err);\n                reject(err);\n            },\n            customChallenge: (challengeParam) => {\n                logger.debug('signIn custom challenge answer required');\n                user['challengeName'] = 'CUSTOM_CHALLENGE';\n                user['challengeParam'] = challengeParam;\n                resolve(user);\n            },\n            mfaRequired: (challengeName, challengeParam) => {\n                logger.debug('signIn MFA required');\n                user['challengeName'] = challengeName;\n                user['challengeParam'] = challengeParam;\n                resolve(user);\n            },\n            mfaSetup: (challengeName, challengeParam) => {\n                logger.debug('signIn mfa setup', challengeName);\n                user['challengeName'] = challengeName;\n                user['challengeParam'] = challengeParam;\n                resolve(user);\n            },\n            newPasswordRequired: (userAttributes, requiredAttributes) => {\n                logger.debug('signIn new password');\n                user['challengeName'] = 'NEW_PASSWORD_REQUIRED';\n                user['challengeParam'] = {\n                    userAttributes,\n                    requiredAttributes\n                };\n                resolve(user);\n            },\n            totpRequired: (challengeName, challengeParam) => {\n                logger.debug('signIn totpRequired');\n                user['challengeName'] = challengeName;\n                user['challengeParam'] = challengeParam;\n                resolve(user);\n            },\n            selectMFAType: (challengeName, challengeParam) => {\n                logger.debug('signIn selectMFAType', challengeName);\n                user['challengeName'] = challengeName;\n                user['challengeParam'] = challengeParam;\n                resolve(user);\n            }\n        };\n    }\n\n    /**\n     * Sign in with a password\n     * @private\n     * @param {AuthenticationDetails} authDetails - the user sign in data\n     * @return - A promise resolves the CognitoUser object if success or mfa required\n     */\n    private signInWithPassword(authDetails: AuthenticationDetails): Promise<CognitoUser | any> {\n        const user = this.createCognitoUser(authDetails.getUsername());\n\n        return new Promise((resolve, reject) => {\n            user.authenticateUser(authDetails, this.authCallbacks(user, resolve, reject));\n        });\n    }\n\n    /**\n     * Sign in without a password\n     * @private\n     * @param {AuthenticationDetails} authDetails - the user sign in data\n     * @return - A promise resolves the CognitoUser object if success or mfa required\n     */\n    private signInWithoutPassword(authDetails: AuthenticationDetails): Promise<CognitoUser | any> {\n        const user = this.createCognitoUser(authDetails.getUsername());\n        user.setAuthenticationFlowType('CUSTOM_AUTH');\n\n        return new Promise((resolve, reject) => {\n            user.initiateAuth(authDetails, this.authCallbacks(user, resolve, reject));\n        });\n    }\n\n    /**\n     * get user current preferred mfa option\n     * this method doesn't work with totp, we need to deprecate it.\n     * @deprecated\n     * @param {CognitoUser} user - the current user\n     * @return - A promise resolves the current preferred mfa option if success\n     */\n    public getMFAOptions(user : CognitoUser | any) : Promise<MFAOption[]> {\n        return new Promise((res, rej) => {\n            user.getMFAOptions((err, mfaOptions) => {\n                if (err) {\n                    logger.debug('get MFA Options failed', err);\n                    rej(err);\n                    return;\n                }\n                logger.debug('get MFA options success', mfaOptions);\n                res(mfaOptions);\n                return;\n            });\n        });\n    }\n\n    /**\n     * get preferred mfa method\n     * @param {CognitoUser} user - the current cognito user\n     */\n    public getPreferredMFA(user: CognitoUser | any): Promise<string> {\n        const that = this;\n        return new Promise((res, rej) => {\n            user.getUserData((err, data) => {\n                if (err) {\n                    logger.debug('getting preferred mfa failed', err);\n                    rej(err);\n                    return;\n                }\n\n                const mfaType = that._getMfaTypeFromUserData(data);\n                if (!mfaType) {\n                    rej('invalid MFA Type');\n                    return;\n                } else {\n                    res(mfaType);\n                    return;\n                }\n            });\n        });\n    }\n\n    private _getMfaTypeFromUserData(data) {\n        let ret = null;\n        const preferredMFA = data.PreferredMfaSetting;\n        // if the user has used Auth.setPreferredMFA() to setup the mfa type\n        // then the \"PreferredMfaSetting\" would exist in the response\n        if (preferredMFA) {\n            ret = preferredMFA;\n        } else {\n            // if mfaList exists but empty, then its noMFA\n            const mfaList = data.UserMFASettingList;\n            if (!mfaList) {\n                // if SMS was enabled by using Auth.enableSMS(),\n                // the response would contain MFAOptions\n                // as for now Cognito only supports for SMS, so we will say it is 'SMS_MFA'\n                // if it does not exist, then it should be NOMFA\n                const MFAOptions = data.MFAOptions;\n                if (MFAOptions) {\n                    ret = 'SMS_MFA';\n                } else {\n                    ret = 'NOMFA';\n                }\n            } else if (mfaList.length === 0) {\n                ret = 'NOMFA';\n            } else {\n                logger.debug('invalid case for getPreferredMFA', data);\n            }\n        }\n        return ret;\n    }\n\n    private _getUserData(user) {\n        return new Promise((res, rej) => {\n            user.getUserData((err, data) => {\n                if (err) {\n                    logger.debug('getting user data failed', err);\n                    rej(err);\n                    return;\n                } else {\n                    res(data);\n                    return;\n                }\n            });\n        });\n\n    }\n    /**\n     * set preferred MFA method\n     * @param {CognitoUser} user - the current Cognito user\n     * @param {string} mfaMethod - preferred mfa method\n     * @return - A promise resolve if success\n     */\n    public async setPreferredMFA(user : CognitoUser | any, mfaMethod : 'TOTP'|'SMS'|'NOMFA'): Promise<string> {\n        const userData = await this._getUserData(user);\n        let smsMfaSettings = null;\n        let totpMfaSettings = null;\n\n        switch(mfaMethod) {\n            case 'TOTP' || 'SOFTWARE_TOKEN_MFA':\n                totpMfaSettings = {\n                    PreferredMfa : true,\n                    Enabled : true\n                };\n                break;\n            case 'SMS' || 'SMS_MFA':\n                smsMfaSettings = {\n                    PreferredMfa : true,\n                    Enabled : true\n                };\n                break;\n            case 'NOMFA':\n                const mfaList = userData['UserMFASettingList'];\n                const currentMFAType = await this._getMfaTypeFromUserData(userData);\n                if (currentMFAType === 'NOMFA') {\n                    return Promise.resolve('No change for mfa type');\n                } else if (currentMFAType === 'SMS_MFA') {\n                    smsMfaSettings = {\n                        PreferredMfa : false,\n                        Enabled : false\n                    };\n                } else if (currentMFAType === 'SOFTWARE_TOKEN_MFA') {\n                    totpMfaSettings = {\n                        PreferredMfa : false,\n                        Enabled : false\n                    };\n                } else {\n                    return Promise.reject('invalid MFA type');\n                }\n                // if there is a UserMFASettingList in the response\n                // we need to disable every mfa type in that list\n                if (mfaList && mfaList.length !== 0) {\n                    // to disable SMS or TOTP if exists in that list\n                    mfaList.forEach(mfaType => {\n                        if (mfaType === 'SMS_MFA') {\n                            smsMfaSettings = {\n                                PreferredMfa : false,\n                                Enabled : false\n                            };\n                        } else if (mfaType === 'SOFTWARE_TOKEN_MFA') {\n                            totpMfaSettings = {\n                                PreferredMfa : false,\n                                Enabled : false\n                            };\n                        }\n                    });\n                }\n                break;\n            default:\n                logger.debug('no validmfa method provided');\n                return Promise.reject('no validmfa method provided');\n        }\n\n        const that = this;\n        return new Promise<string>((res, rej) => {\n            user.setUserMfaPreference(smsMfaSettings, totpMfaSettings, (err, result) => {\n                if (err) {\n                    logger.debug('Set user mfa preference error', err);\n                    return rej(err);\n\n                }\n                logger.debug('Set user mfa success', result);\n                return res(result);\n            });\n        });\n    }\n\n    /**\n     * diable SMS\n     * @deprecated\n     * @param {CognitoUser} user - the current user\n     * @return - A promise resolves is success\n     */\n    public disableSMS(user : CognitoUser) : Promise<string> {\n        return new Promise((res, rej) => {\n            user.disableMFA((err, data) => {\n                if (err) {\n                    logger.debug('disable mfa failed', err);\n                    rej(err);\n                    return;\n                }\n                logger.debug('disable mfa succeed', data);\n                res(data);\n                return;\n            });\n        });\n    }\n\n    /**\n     * enable SMS\n     * @deprecated\n     * @param {CognitoUser} user - the current user\n     * @return - A promise resolves is success\n     */\n    public enableSMS(user: CognitoUser): Promise<string> {\n        return new Promise((res, rej) => {\n            user.enableMFA((err, data) => {\n                if (err) {\n                    logger.debug('enable mfa failed', err);\n                    rej(err);\n                    return;\n                }\n                logger.debug('enable mfa succeed', data);\n                res(data);\n                return;\n            });\n        });\n    }\n\n    /**\n     * Setup TOTP\n     * @param {CognitoUser} user - the current user\n     * @return - A promise resolves with the secret code if success\n     */\n    public setupTOTP(user: CognitoUser | any): Promise<string> {\n        return new Promise((res, rej) => {\n            user.associateSoftwareToken({\n                onFailure: (err) => {\n                    logger.debug('associateSoftwareToken failed', err);\n                    rej(err);\n                    return;\n                },\n                associateSecretCode: (secretCode) => {\n                    logger.debug('associateSoftwareToken sucess', secretCode);\n                    res(secretCode);\n                    return;\n                }\n            });\n        });\n    }\n\n    /**\n     * verify TOTP setup\n     * @param {CognitoUser} user - the current user\n     * @param {string} challengeAnswer - challenge answer\n     * @return - A promise resolves is success\n     */\n    public verifyTotpToken(user: CognitoUser | any, challengeAnswer: string): Promise<CognitoUserSession> {\n        logger.debug('verfication totp token', user, challengeAnswer);\n        return new Promise((res, rej) => {\n            user.verifySoftwareToken(challengeAnswer, 'My TOTP device', {\n                onFailure: (err) => {\n                    logger.debug('verifyTotpToken failed', err);\n                    rej(err);\n                    return;\n                },\n                onSuccess: (data) => {\n                    logger.debug('verifyTotpToken success', data);\n                    res(data);\n                    return;\n                }\n            });\n        });\n    }\n\n    /**\n     * Send MFA code to confirm sign in\n     * @param {Object} user - The CognitoUser object\n     * @param {String} code - The confirmation code\n     */\n    public confirmSignIn(\n        user: CognitoUser | any,\n        code: string,\n        mfaType?: 'SMS_MFA'|'SOFTWARE_TOKEN_MFA'|null\n    ): Promise<CognitoUser | any> {\n        if (!code) { return Promise.reject('Code cannot be empty'); }\n\n        const that = this;\n        return new Promise((resolve, reject) => {\n            user.sendMFACode(\n                code, {\n                    onSuccess: async (session) => {\n                        logger.debug(session);\n                        try {\n                            await Credentials.clear();\n                            const cred = await Credentials.set(session, 'session');\n                            logger.debug('succeed to get cognito credentials', cred);\n                        } catch (e) {\n                            logger.debug('cannot get cognito credentials', e);\n                        } finally {\n                            that.user = user;\n                            dispatchAuthEvent('signIn', user);\n                            resolve(user);\n                        }\n                    },\n                    onFailure: (err) => {\n                        logger.debug('confirm signIn failure', err);\n                        reject(err);\n                    }\n                },\n                mfaType);\n        });\n    }\n\n    public completeNewPassword(\n        user: CognitoUser | any,\n        password: string,\n        requiredAttributes: any\n    ): Promise<CognitoUser | any> {\n        if (!password) { return Promise.reject('Password cannot be empty'); }\n\n        const that = this;\n        return new Promise((resolve, reject) => {\n            user.completeNewPasswordChallenge(password, requiredAttributes, {\n                onSuccess: async (session) => {\n                    logger.debug(session);\n                    try {\n                        await Credentials.clear();\n                        const cred = await Credentials.set(session, 'session');\n                        logger.debug('succeed to get cognito credentials', cred);\n                    } catch (e) {\n                        logger.debug('cannot get cognito credentials', e);\n                    } finally {\n                        that.user = user;\n                        dispatchAuthEvent('signIn', user);\n                        resolve(user);\n                    }\n                },\n                onFailure: (err) => {\n                    logger.debug('completeNewPassword failure', err);\n                    dispatchAuthEvent('completeNewPassword_failure', err);\n                    reject(err);\n                },\n                mfaRequired: (challengeName, challengeParam) => {\n                    logger.debug('signIn MFA required');\n                    user['challengeName'] = challengeName;\n                    user['challengeParam'] = challengeParam;\n                    resolve(user);\n                },\n                mfaSetup: (challengeName, challengeParam) => {\n                    logger.debug('signIn mfa setup', challengeName);\n                    user['challengeName'] = challengeName;\n                    user['challengeParam'] = challengeParam;\n                    resolve(user);\n                }\n            });\n        });\n    }\n\n    /**\n     * Send the answer to a custom challenge\n     * @param {CognitoUser} user - The CognitoUser object\n     * @param {String} challengeResponses - The confirmation code\n     */\n    public sendCustomChallengeAnswer(user:CognitoUser | any, challengeResponses: string): Promise<CognitoUser | any> {\n        if (!this.userPool) { return Promise.reject('No userPool'); }\n        if (!challengeResponses) { return Promise.reject('Challenge response cannot be empty'); }\n\n        const that = this;\n        return new Promise((resolve, reject) => {\n            user.sendCustomChallengeAnswer(challengeResponses, this.authCallbacks(user, resolve, reject));\n        });\n    }\n\n    /**\n     * Update an authenticated users' attributes\n     * @param {CognitoUser} - The currently logged in user object\n     * @return {Promise}\n     **/\n    public updateUserAttributes(user: CognitoUser | any, attributes:object): Promise<string> {\n        const attributeList:ICognitoUserAttributeData[] = [];\n        const that = this;\n        return new Promise((resolve, reject) => {\n            that.userSession(user).then(session => {\n                for (const key in attributes) {\n                    if ( key !== 'sub' &&\n                        key.indexOf('_verified') < 0) {\n                        const attr:ICognitoUserAttributeData = {\n                            'Name': key,\n                            'Value': attributes[key]\n                        };\n                        attributeList.push(attr);\n                    }\n                }\n                user.updateAttributes(attributeList, (err,result) => {\n                    if (err) { return reject(err); } else { return resolve(result); }\n                });\n            });\n        });\n    }\n    /**\n     * Return user attributes\n     * @param {Object} user - The CognitoUser object\n     * @return - A promise resolves to user attributes if success\n     */\n    public userAttributes(user:CognitoUser | any): Promise<CognitoUserAttribute[]> {\n        return new Promise((resolve, reject) => {\n            this.userSession(user).then(session => {\n                user.getUserAttributes((err, attributes) => {\n                    if (err) { reject(err); } else { resolve(attributes); }\n                });\n            });\n        });\n    }\n\n    public verifiedContact(user: CognitoUser | any) {\n        const that = this;\n        return this.userAttributes(user)\n            .then(attributes => {\n                const attrs = that.attributesToObject(attributes);\n                const unverified = {};\n                const verified = {};\n                if (attrs['email']) {\n                    if (attrs['email_verified']) {\n                        verified['email'] = attrs['email'];\n                    } else {\n                        unverified['email'] = attrs['email'];\n                    }\n                }\n                if (attrs['phone_number']) {\n                    if (attrs['phone_number_verified']) {\n                        verified['phone_number'] = attrs['phone_number'];\n                    } else {\n                        unverified['phone_number'] = attrs['phone_number'];\n                    }\n                }\n                return {\n                    verified,\n                    unverified\n                };\n            });\n    }\n\n    /**\n     * Get current authenticated user\n     * @return - A promise resolves to current authenticated CognitoUser if success\n     */\n    public currentUserPoolUser(params?: CurrentUserOpts): Promise<CognitoUser | any> {\n        if (!this.userPool) { return Promise.reject('No userPool'); }\n        const that = this;\n        return new Promise((res, rej) => {\n            this._storageSync.then(() => {\n                const user = that.userPool.getCurrentUser();\n                if (!user) {\n                    logger.debug('Failed to get user from user pool');\n                    rej('No current user');\n                    return;\n                }\n\n                // refresh the session if the session expired.\n                user.getSession((err, session) => {\n                    if (err) {\n                        logger.debug('Failed to get the user session', err);\n                        rej(err);\n                        return;\n                    }\n\n                    // get user data from Cognito\n                    const bypassCache = params? params.bypassCache: false;\n                    user.getUserData(\n                        (err, data) => {\n                            if (err) {\n                                logger.debug('getting user data failed', err);\n                                // Make sure the user is still valid\n                                if (err.message === 'User is disabled' || err.message === 'User does not exist.') {\n                                    rej(err);\n                                } else {\n                                    // the error may also be thrown when lack of permissions to get user info etc\n                                    // in that case we just bypass the error\n                                    res(user);\n                                }\n                                return;\n                            }\n                            const preferredMFA = data.PreferredMfaSetting || 'NOMFA';\n                            const attributeList = [];\n\n                            for (let i = 0; i < data.UserAttributes.length; i++) {\n                                const attribute = {\n                                    Name: data.UserAttributes[i].Name,\n                                    Value: data.UserAttributes[i].Value,\n                                };\n                                const userAttribute = new CognitoUserAttribute(attribute);\n                                attributeList.push(userAttribute);\n                            }\n\n                            const attributes = that.attributesToObject(attributeList);\n                            Object.assign(user, {attributes, preferredMFA});\n                            return res(user);\n                        },\n                        { bypassCache }\n                    );\n                });\n            }).catch(e => {\n                logger.debug('Failed to sync cache info into memory', e);\n                return rej(e);\n            });\n        });\n    }\n\n    /**\n     * Get current authenticated user\n     * @param {CurrentUserOpts} - options for getting the current user\n     * @return - A promise resolves to current authenticated CognitoUser if success\n     */\n    public async currentAuthenticatedUser(params?: CurrentUserOpts): Promise<CognitoUser|any> {\n        logger.debug('getting current authenticted user');\n        let federatedUser = null;\n        try {\n            await this._storageSync;\n        } catch (e) {\n            logger.debug('Failed to sync cache info into memory', e);\n            throw e;\n        }\n\n        try {\n            federatedUser = JSON.parse(this._storage.getItem('aws-amplify-federatedInfo')).user;\n        } catch (e) {\n            logger.debug('cannot load federated user from auth storage');\n        }\n\n        if (federatedUser) {\n            this.user = federatedUser;\n            logger.debug('get current authenticated federated user', this.user);\n            return this.user;\n        } else {\n            logger.debug('get current authenticated userpool user');\n            let user = null;\n            try {\n                user = await this.currentUserPoolUser(params);\n            } catch (e) {\n                if (e === 'No userPool') {\n                    logger.error('Cannot get the current user because the user pool is missing. ' +\n                        'Please make sure the Auth module is configured with a valid Cognito User Pool ID');\n                }\n                logger.debug('The user is not authenticated by the error', e);\n                throw ('not authenticated');\n            }\n            this.user = user;\n            return this.user;\n        }\n    }\n\n    /**\n     * Get current user's session\n     * @return - A promise resolves to session object if success\n     */\n    public currentSession() : Promise<CognitoUserSession> {\n        const that = this;\n        logger.debug('Getting current session');\n        if (!this.userPool) { return Promise.reject('No userPool'); }\n\n        return new Promise((res, rej) => {\n            that.currentUserPoolUser().then(user => {\n                that.userSession(user).then(session => {\n                    res(session);\n                    return;\n                }).catch(e => {\n                    logger.debug('Failed to get the current session', e);\n                    rej(e);\n                    return;\n                });\n            }).catch(e => {\n                logger.debug('Failed to get the current user', e);\n                rej(e);\n                return;\n            });\n        });\n    }\n\n    /**\n     * Get the corresponding user session\n     * @param {Object} user - The CognitoUser object\n     * @return - A promise resolves to the session\n     */\n    public userSession(user) : Promise<CognitoUserSession> {\n        if (!user) {\n            logger.debug('the user is null');\n            return Promise.reject('Failed to get the session because the user is empty');\n        }\n        return new Promise((resolve, reject) => {\n            logger.debug('Getting the session from this user:', user);\n            user.getSession(function(err, session) {\n                if (err) {\n                    logger.debug('Failed to get the session from user', user);\n                    reject(err);\n                    return;\n                } else {\n                    logger.debug('Succeed to get the user session', session);\n                    resolve(session);\n                    return;\n                }\n            });\n        });\n    }\n\n    /**\n     * Get  authenticated credentials of current user.\n     * @return - A promise resolves to be current user's credentials\n     */\n    public async currentUserCredentials(): Promise<ICredentials> {\n        const that = this;\n        logger.debug('Getting current user credentials');\n\n        try {\n            await this._storageSync;\n        } catch (e) {\n            logger.debug('Failed to sync cache info into memory', e);\n            throw e;\n        }\n\n        // first to check whether there is federation info in the auth storage\n        let federatedInfo = null;\n        try {\n            federatedInfo = JSON.parse(this._storage.getItem('aws-amplify-federatedInfo'));\n        } catch (e) {\n            logger.debug('failed to get or parse item aws-amplify-federatedInfo', e);\n        }\n\n        if (federatedInfo) {\n            // refresh the jwt token here if necessary\n            return Credentials.refreshFederatedToken(federatedInfo);\n        } else {\n            return this.currentSession()\n                .then(session => {\n                    logger.debug('getting session success', session);\n                    return Credentials.set(session, 'session');\n                }).catch((error) => {\n                    logger.debug('getting session failed', error);\n                    return Credentials.set(null, 'guest');\n                });\n        }\n    }\n\n\n    public currentCredentials(): Promise<ICredentials> {\n        logger.debug('getting current credntials');\n        return Credentials.get();\n    }\n\n    /**\n     * Initiate an attribute confirmation request\n     * @param {Object} user - The CognitoUser\n     * @param {Object} attr - The attributes to be verified\n     * @return - A promise resolves to callback data if success\n     */\n    public verifyUserAttribute(user: CognitoUser | any, attr: string): Promise<void> {\n        return new Promise((resolve, reject) => {\n            user.getAttributeVerificationCode(attr, {\n                onSuccess() { return resolve(); },\n                onFailure(err) { return reject(err); }\n            });\n        });\n    }\n\n    /**\n     * Confirm an attribute using a confirmation code\n     * @param {Object} user - The CognitoUser\n     * @param {Object} attr - The attribute to be verified\n     * @param {String} code - The confirmation code\n     * @return - A promise resolves to callback data if success\n     */\n    public verifyUserAttributeSubmit(user: CognitoUser | any, attr: string, code: string): Promise<string> {\n        if (!code) { return Promise.reject('Code cannot be empty'); }\n\n        return new Promise((resolve, reject) => {\n            user.verifyAttribute(attr, code, {\n                onSuccess(data) {\n                    resolve(data);\n                    return;\n                },\n                onFailure(err) {\n                    reject(err);\n                    return;\n                }\n            });\n        });\n    }\n\n    public verifyCurrentUserAttribute(attr: string): Promise<void> {\n        const that = this;\n        return that.currentUserPoolUser()\n            .then(user => that.verifyUserAttribute(user, attr));\n    }\n\n    /**\n     * Confirm current user's attribute using a confirmation code\n     * @param {Object} attr - The attribute to be verified\n     * @param {String} code - The confirmation code\n     * @return - A promise resolves to callback data if success\n     */\n    verifyCurrentUserAttributeSubmit(attr: string, code: string): Promise<string> {\n        const that = this;\n        return that.currentUserPoolUser()\n            .then(user => that.verifyUserAttributeSubmit(user, attr, code));\n    }\n\n    private async cognitoIdentitySignOut(opts: SignOutOpts, user: CognitoUser | any) {\n        return new Promise((res, rej) => {\n            if (opts && opts.global) {\n                logger.debug('user global sign out', user);\n                // in order to use global signout\n                // we must validate the user as an authenticated user by using getSession\n                user.getSession((err, result) => {\n                    if (err) {\n                        logger.debug('failed to get the user session', err);\n                        return rej(err);\n                    }\n                    user.globalSignOut({\n                        onSuccess: (data) => {\n                            logger.debug('global sign out success');\n                            if (this._cognitoAuthClient) {\n                                this._cognitoAuthClient.signOut();\n                            }\n                            return res();\n                        },\n                        onFailure: (err) => {\n                            logger.debug('global sign out failed', err);\n                            return rej(err);\n                        }\n                    });\n                });\n            } else {\n                logger.debug('user sign out', user);\n                user.signOut();\n                if (this._cognitoAuthClient) {\n                    this._cognitoAuthClient.signOut();\n                }\n                return res();\n            }\n        });\n    }\n\n    /**\n     * Sign out method\n     * @\n     * @return - A promise resolved if success\n     */\n    public async signOut(opts?: SignOutOpts): Promise<any> {\n        try {\n            await this.cleanCachedItems();\n        } catch (e) {\n            logger.debug('failed to clear cached items');\n        }\n\n        if (this.userPool) {\n            const user = this.userPool.getCurrentUser();\n            if (user) {\n                await this.cognitoIdentitySignOut(opts, user);\n            } else {\n                logger.debug('no current Cognito user');\n            }\n        } else {\n            logger.debug('no Congito User pool');\n        }\n\n        dispatchAuthEvent('signOut', this.user);\n        this.user = null;\n    }\n\n    private async cleanCachedItems() {\n        // clear cognito cached item\n        await Credentials.clear();\n    }\n\n    /**\n     * Change a password for an authenticated user\n     * @param {Object} user - The CognitoUser object\n     * @param {String} oldPassword - the current password\n     * @param {String} newPassword - the requested new password\n     * @return - A promise resolves if success\n     */\n    public changePassword(user: CognitoUser | any, oldPassword: string, newPassword: string): Promise<\"SUCCESS\"> {\n        return new Promise((resolve, reject) => {\n            this.userSession(user).then(session => {\n                user.changePassword(oldPassword, newPassword, (err, data) => {\n                    if (err) {\n                        logger.debug('change password failure', err);\n                        return reject(err);\n                    } else {\n                        return resolve(data);\n                    }\n                });\n            });\n        });\n    }\n\n    /**\n     * Initiate a forgot password request\n     * @param {String} username - the username to change password\n     * @return - A promise resolves if success\n     */\n    public forgotPassword(username: string): Promise<any> {\n        if (!this.userPool) { return Promise.reject('No userPool'); }\n        if (!username) { return Promise.reject('Username cannot be empty'); }\n\n        const user = this.createCognitoUser(username);\n        return new Promise((resolve, reject) => {\n            user.forgotPassword({\n                onSuccess: () => {\n                    resolve();\n                    return;\n                },\n                onFailure: err => {\n                    logger.debug('forgot password failure', err);\n                    reject(err);\n                    return;\n                },\n                inputVerificationCode: data => {\n                    resolve(data);\n                    return;\n                }\n            });\n        });\n    }\n\n    /**\n     * Confirm a new password using a confirmation Code\n     * @param {String} username - The username\n     * @param {String} code - The confirmation code\n     * @param {String} password - The new password\n     * @return - A promise that resolves if success\n     */\n    public forgotPasswordSubmit(\n        username: string,\n        code: string,\n        password: string\n    ): Promise<void> {\n        if (!this.userPool) { return Promise.reject('No userPool'); }\n        if (!username) { return Promise.reject('Username cannot be empty'); }\n        if (!code) { return Promise.reject('Code cannot be empty'); }\n        if (!password) { return Promise.reject('Password cannot be empty'); }\n\n        const user = this.createCognitoUser(username);\n        return new Promise((resolve, reject) => {\n            user.confirmPassword(code, password, {\n                onSuccess: () => {\n                    resolve();\n                    return;\n                },\n                onFailure: err => {\n                    reject(err);\n                    return;\n                }\n            });\n        });\n    }\n\n    /**\n     * Get user information\n     * @async\n     * @return {Object }- current User's information\n     */\n    public async currentUserInfo() {\n        const source = Credentials.getCredSource();\n\n        if (!source || source === 'aws' || source === 'userPool') {\n            const user = await this.currentUserPoolUser()\n                .catch(err => logger.debug(err));\n            if (!user) { return null; }\n\n            try {\n                const attributes = await this.userAttributes(user);\n                const userAttrs:object = this.attributesToObject(attributes);\n                let credentials = null;\n                try {\n                    credentials = await this.currentCredentials();\n                } catch (e) {\n                    logger.debug('Failed to retrieve credentials while getting current user info', e);\n                }\n\n\n                const info = {\n                    'id': credentials? credentials.identityId : undefined,\n                    'username': user.getUsername(),\n                    'attributes': userAttrs\n                };\n                return info;\n            } catch(err) {\n                logger.debug('currentUserInfo error', err);\n                return {};\n            }\n        }\n\n        if (source === 'federated') {\n            const user = this.user;\n            return user? user : {};\n        }\n    }\n\n    /**\n     * For federated login\n     * @param {String} provider - federation login provider\n     * @param {FederatedResponse} response - response should have the access token\n     * the identity id (optional)\n     * and the expiration time (the universal time)\n     * @param {String} user - user info\n     */\n    public async federatedSignIn(\n        provider: 'google'|'facebook'|'amazon'|'developer'|string,\n        response: FederatedResponse,\n        user: FederatedUser\n    ): Promise<ICredentials>{\n        // To check if the user is already logged in\n        try {\n            const loggedInUser = await this.currentAuthenticatedUser();\n            logger.warn(`There is already a signed in user: ${loggedInUser} in your app.\n                You should not call Auth.federatedSignIn method again as it may cause unexpected behavior.`);\n        } catch (e) {}\n\n        const { token, identity_id, expires_at } = response;\n        // Because Credentials.set would update the user info with identity id\n        // So we need to retrieve the user again.\n        const credentials = await Credentials.set({ provider, token, identity_id, user, expires_at }, 'federation');\n        const currentUser = await this.currentAuthenticatedUser();\n        dispatchAuthEvent('signIn', currentUser);\n        logger.debug('federated sign in credentials', credentials);\n        return credentials;\n    }\n\n    /**\n     * Compact version of credentials\n     * @param {Object} credentials\n     * @return {Object} - Credentials\n     */\n    public essentialCredentials(credentials): ICredentials {\n        return {\n            accessKeyId: credentials.accessKeyId,\n            sessionToken: credentials.sessionToken,\n            secretAccessKey: credentials.secretAccessKey,\n            identityId: credentials.identityId,\n            authenticated: credentials.authenticated\n        };\n    }\n\n    private attributesToObject(attributes) {\n        const obj = {};\n        if (attributes) {\n            attributes.map(attribute => {\n                if (attribute.Value === 'true') {\n                    obj[attribute.Name] = true;\n                } else if (attribute.Value === 'false') {\n                    obj[attribute.Name] = false;\n                } else {\n                    obj[attribute.Name] = attribute.Value;\n                }\n            });\n        }\n        return obj;\n    }\n\n    private createCognitoUser(username: string): CognitoUser {\n        const userData: ICognitoUserData = {\n            Username: username,\n            Pool: this.userPool,\n        };\n        userData.Storage = this._storage;\n\n        const { authenticationFlowType } = this._config;\n\n        const user = new CognitoUser(userData);\n        if (authenticationFlowType) {\n            user.setAuthenticationFlowType(authenticationFlowType);\n        }\n        return user;\n    }\n}\n"]}},"error":null,"hash":"a250c46178308c068ed540410aaa56a1","cacheData":{"env":{}}}